<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload - Gerenciador</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body class="bg-gray-50">
    <!-- Navbar -->
    <nav class="bg-white shadow-md mb-8">
        <div class="container mx-auto px-4 py-4 flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <i class="fas fa-box text-blue-600 text-2xl"></i>
                <h1 class="text-2xl font-bold text-gray-800">Gerenciador de Produtos</h1>
            </div>
            <div class="flex space-x-6">
                <a href="index.html" class="text-gray-600 hover:text-blue-600">Dashboard</a>
                <a href="products.html" class="text-gray-600 hover:text-blue-600">Produtos</a>
                <a href="upload.html" class="text-blue-600 font-semibold">Upload</a>
                <a href="categories.html" class="text-gray-600 hover:text-blue-600">Categorias</a>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 max-w-4xl">
        <div class="mb-6">
            <h2 class="text-3xl font-bold text-gray-900">Upload de Produtos</h2>
            <p class="text-gray-600 mt-1">Faça upload de um arquivo ZIP contendo as pastas dos produtos</p>
        </div>

        <!-- Estrutura Esperada -->
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
            <h3 class="text-lg font-semibold text-blue-900 mb-2 flex items-center">
                <i class="fas fa-info-circle mr-2"></i>
                Estrutura do ZIP
            </h3>
            <p class="text-blue-800 text-sm mb-2">O ZIP deve conter pastas com os produtos. Exemplo:</p>
            <div class="bg-white rounded p-3 font-mono text-xs text-gray-700">
                produtos.zip<br>
                ├── iMac_24_M1_novo/<br>
                │   ├── descricao.txt<br>
                │   ├── info.txt<br>
                │   └── imagem1.jpg<br>
                ├── MacBook_Pro_seminovo/<br>
                │   ├── descricao.txt<br>
                │   └── foto.png<br>
            </div>
            <p class="text-blue-700 text-xs mt-2">
                <strong>descricao.txt:</strong> Nome na 1ª linha, descrição no meio, preço na última linha<br>
                <strong>info.txt:</strong> Opcional - informações adicionais
            </p>
        </div>

        <!-- Dropzone -->
        <div id="dropzone" class="bg-white border-2 border-dashed border-gray-300 rounded-lg p-12 text-center cursor-pointer hover:border-blue-500 transition mb-6">
            <input type="file" id="fileInput" accept=".zip" class="hidden">
            <i class="fas fa-file-archive text-gray-400 text-6xl mb-4"></i>
            <p class="text-lg font-medium text-gray-900 mb-2">
                Arraste um arquivo ZIP ou clique para selecionar
            </p>
            <p class="text-gray-600">Tamanho máximo: 500MB • Formato: ZIP</p>
        </div>

        <!-- Debug Info -->
        <div id="debugInfo" class="hidden bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
            <h3 class="text-lg font-semibold text-yellow-900 mb-2">
                <i class="fas fa-bug mr-2"></i>
                Conteúdo do ZIP
            </h3>
            <pre id="debugContent" class="text-xs text-gray-700 max-h-60 overflow-auto bg-white p-3 rounded"></pre>
        </div>

        <!-- Progress -->
        <div id="progressSection" class="hidden bg-white rounded-lg shadow-md p-6 mb-6">
            <h3 class="text-xl font-semibold mb-4">Processando...</h3>
            <div class="mb-4">
                <div class="bg-gray-200 rounded-full h-4 overflow-hidden">
                    <div id="progressBar" class="bg-blue-600 h-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <p id="progressText" class="text-center text-gray-600 mt-2">0 de 0 produtos</p>
            </div>
        </div>

        <!-- Products List -->
        <div id="productsSection" class="hidden bg-white rounded-lg shadow-md p-6">
            <h3 class="text-xl font-semibold mb-4">Produtos Processados</h3>
            <div id="productsList" class="space-y-2 max-h-96 overflow-y-auto"></div>
        </div>
    </div>

    <script src="/js/api.js"></script>
    <script>
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');

        dropzone.addEventListener('click', () => fileInput.click());
        
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('border-blue-500', 'bg-blue-50');
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('border-blue-500', 'bg-blue-50');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('border-blue-500', 'bg-blue-50');
            const files = e.dataTransfer.files;
            if (files.length > 0) processFile(files[0]);
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) processFile(e.target.files[0]);
        });

        async function processFile(file) {
            if (!file.name.endsWith('.zip')) {
                showNotification('Por favor, selecione um arquivo ZIP', 'error');
                return;
            }

            try {
                const zip = await JSZip.loadAsync(file);
                
                // Debug: Mostrar conteúdo do ZIP
                const allFiles = [];
                zip.forEach((path, entry) => {
                    allFiles.push(`${entry.dir ? '[DIR]' : '[FILE]'} ${path}`);
                });
                
                document.getElementById('debugInfo').classList.remove('hidden');
                document.getElementById('debugContent').textContent = allFiles.join('\n');

                // Encontrar pastas de produtos (buscar em todos os níveis)
                const folders = new Set();
                
                zip.forEach((path, entry) => {
                    if (!entry.dir && path.includes('/')) {
                        // Pegar a pasta pai do arquivo
                        const parts = path.split('/');
                        if (parts.length >= 2) {
                            // Se tem mais de 1 nível, pegar o penúltimo
                            const folder = parts.slice(0, -1).join('/');
                            folders.add(folder);
                        }
                    }
                });

                const folderArray = Array.from(folders);

                if (folderArray.length === 0) {
                    showNotification('⚠️ Nenhuma pasta com arquivos encontrada no ZIP. Verifique a estrutura acima.', 'error');
                    return;
                }

                showNotification(`✅ ${folderArray.length} pasta(s) encontrada(s)!`, 'success');
                
                document.getElementById('progressSection').classList.remove('hidden');
                document.getElementById('productsSection').classList.remove('hidden');

                const products = [];
                const productsList = document.getElementById('productsList');
                productsList.innerHTML = '';

                for (let i = 0; i < folderArray.length; i++) {
                    const folder = folderArray[i];
                    const folderName = folder.split('/').pop() || folder;
                    updateProgress(i, folderArray.length);

                    try {
                        // Ler arquivos
                        const descricaoFile = zip.file(`${folder}/descricao.txt`);
                        const infoFile = zip.file(`${folder}/info.txt`);

                        const descricao = descricaoFile ? await descricaoFile.async('text') : '';
                        const info = infoFile ? await infoFile.async('text') : '';

                        // Coletar imagens do ZIP
                        const imageFiles = [];
                        let imageCount = 0;
                        zip.forEach((path, zipEntry) => {
                            if (path.startsWith(folder + '/') && /\.(jpg|jpeg|png|gif|webp)$/i.test(path) && !zipEntry.dir) {
                                imageCount++;
                                imageFiles.push({
                                    path: path,
                                    zipEntry: zipEntry,
                                    order: imageCount
                                });
                            }
                        });

                        // Upload das imagens para o servidor
                        const uploadedImages = [];
                        for (let j = 0; j < imageFiles.length; j++) {
                            try {
                                const imageFile = imageFiles[j];
                                const blob = await imageFile.zipEntry.async('blob');
                                const fileName = imageFile.path.split('/').pop();
                                
                                const formData = new FormData();
                                formData.append('image', blob, fileName);

                                const uploadResponse = await fetchAPI('/api/admin/products/upload-image', {
                                    method: 'POST',
                                    body: formData
                                });

                                if (uploadResponse.success && uploadResponse.data) {
                                    uploadedImages.push({
                                        url: uploadResponse.data.url,
                                        order: imageFile.order
                                    });
                                }
                            } catch (uploadError) {
                                console.warn(`Erro ao fazer upload da imagem: ${uploadError.message}`);
                            }
                        }

                        // Parsear dados
                        const productData = parseProductData(folderName, descricao, info);
                        productData.images = uploadedImages;
                        
                        products.push(productData);

                        // Adicionar à lista
                        const priceText = productData.price && productData.price > 0 
                            ? `R$ ${productData.price.toFixed(2)}` 
                            : 'Sem preço';
                        addProductToList(folderName, 'success', `${priceText} - ${imageCount} imagens`);
                    } catch (error) {
                        addProductToList(folderName, 'error', error.message);
                    }
                }

                updateProgress(folderArray.length, folderArray.length);

                // Enviar para API
                if (products.length > 0) {
                    try {
                        console.log('Enviando produtos:', products);
                        const response = await fetchAPI('/api/admin/products/bulk', {
                            method: 'POST',
                            body: JSON.stringify({ products }),
                        });
                        console.log('Resposta da API:', response);
                        
                        if (response.success) {
                            showNotification(
                                `✅ ${response.created} de ${response.total} produtos criados com sucesso!`,
                                'success'
                            );
                            
                            // Mostrar erros se houver
                            if (response.errors > 0) {
                                const errorList = response.errorDetails.map(e => 
                                    `<li><strong>${e.product}:</strong> ${e.error}</li>`
                                ).join('');
                                showNotification(
                                    `⚠️ ${response.errors} produto(s) com erro:<br><ul class="text-left mt-2">${errorList}</ul>`,
                                    'warning'
                                );
                            }
                            
                            setTimeout(() => {
                                window.location.href = 'products.html';
                            }, 3000);
                        } else {
                            throw new Error('Nenhum produto foi criado');
                        }
                    } catch (error) {
                        console.error('Erro completo:', error);
                        showNotification('❌ Erro ao salvar produtos: ' + error.message, 'error');
                    }
                }
            } catch (error) {
                showNotification('❌ Erro ao processar ZIP: ' + error.message, 'error');
                console.error(error);
            }
        }

        function parseProductData(folderName, descricao, info) {
            const descLines = descricao.split('\n').filter(l => l.trim());
            const name = descLines[0] || folderName;
            const description = descLines.slice(1, -1).join('\n').trim() || 'Sem descrição';
            
            // Extrair preço - procurar em todas as linhas, não só na última
            // Preço é OPCIONAL - se não encontrar, será null
            let price = null;
            for (let i = descLines.length - 1; i >= 0; i--) {
                const line = descLines[i];
                const priceMatch = line.match(/R?\$?\s*([\d.,]+)/);
                if (priceMatch) {
                    const priceStr = priceMatch[1].replace(/\./g, '').replace(',', '.');
                    const parsedPrice = parseFloat(priceStr);
                    if (!isNaN(parsedPrice) && parsedPrice > 0) {
                        price = parsedPrice;
                        break;
                    }
                }
            }

            let category = null;
            let brand = null;
            let condition = null;
            let urlOriginal = null;

            const infoLines = info.split('\n');
            infoLines.forEach(line => {
                if (line.includes('Nome:')) category = line.split(':')[1]?.trim();
                if (line.includes('URL:')) urlOriginal = line.split('URL:')[1]?.trim();
            });

            // Detectar marca e condição do nome da pasta
            const folderLower = folderName.toLowerCase();
            if (folderLower.includes('apple') || folderLower.includes('imac') || folderLower.includes('macbook')) brand = 'Apple';
            if (folderLower.includes('dell')) brand = 'Dell';
            if (folderLower.includes('hp')) brand = 'HP';
            if (folderLower.includes('lenovo')) brand = 'Lenovo';
            
            if (folderLower.includes('novo') && !folderLower.includes('semi')) condition = 'novo';
            if (folderLower.includes('semi') || folderLower.includes('seminovo')) condition = 'semi-novo';
            if (folderLower.includes('usado')) condition = 'usado';

            // Detectar categoria
            if (!category) {
                if (folderLower.includes('imac')) category = 'iMac';
                else if (folderLower.includes('macbook')) category = 'MacBook';
                else if (folderLower.includes('notebook')) category = 'Notebook';
                else if (folderLower.includes('desktop')) category = 'Desktop';
                else {
                    const parts = folderName.split('_');
                    category = parts[0] || 'Outros';
                }
            }

            const product = {
                name,
                description,
                category,
                brand,
                condition,
                urlOriginal,
                specs: {},
                images: [],
            };
            
            // Só adicionar preço se existir e for válido
            if (price !== null && price > 0) {
                product.price = price;
            }
            
            return product;
        }

        function updateProgress(current, total) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = `${current} de ${total} produtos`;
        }

        function addProductToList(name, status, info = '') {
            const list = document.getElementById('productsList');
            const icons = {
                success: '<i class="fas fa-check-circle text-green-600 text-xl"></i>',
                error: '<i class="fas fa-times-circle text-red-600 text-xl"></i>',
            };

            list.innerHTML += `
                <div class="flex items-center justify-between p-3 border border-gray-200 rounded-lg">
                    <div class="flex items-center space-x-3">
                        ${icons[status]}
                        <div>
                            <p class="font-medium text-gray-900">${name}</p>
                            ${info ? `<p class="text-sm text-gray-600">${info}</p>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>
